# Divergent Change

We structure our software to make change easier; after all, software is meant to be soft. When we make a change, we want to be able to jump to a single clear point in the system and make the change. When you can’t do this, you are smelling one of two closely related pungencies.

Divergent change occurs when one module is often changed in different ways for different reasons. If you look at a module and say, “Well, I will have to change these three functions every time I get a new database; I have to change these four functions every time there is a new financial instrument,” this is an indication of divergent change. The database interaction and financial processing problems are separate contexts, and we can make our programming life better by moving such contexts into separate modules. That way, when we have a change to one context, we only have to understand that one context and ignore the other. We always found this to be important, but now, with our brains shrinking with age, it becomes all the more imperative. Of course, you often discover this only after you’ve added a few databases or financial instruments; context boundaries are usually unclear in the early days of a program and continue to shift as a software system's capabilities change.

If the two aspects naturally form a sequence—for example, you get data from the database and then apply your financial processing on it—then Split Phase separates the two with a clear data structure between them. If there's more back-and-forth in the calls, then create appropriate modules and use Move Function to divide the processing up. If functions mix the two types of processing within themselves, use Extract Function to separate them before moving. If the modules are classes, then Extract Class helps formalize how to do the split.
