# Divergent Change（发散式变化）

我们希望软件能够更容易被修改——毕竟软件本来就该是“软”的。一旦需要修改，我们希望能够跳到系统的某一点，只在该处做修改。如果不能做到这点，你就嗅出两种紧密相关的刺鼻味道中的一种了。

如果某个类经常因为不同的原因在不同的方向上发生变化，Divergent Change就出现了。当你看着一个类说：“呃，如果新加入一个数据库，我必须修改这三个函数；如果新出现一种金融工具，我必须修改这四个函数。”这就是发散式变化的征兆。数据库交互和金融逻辑处理是两个不同的上下文，将它们分别搬移到各自独立的模块中，能让程序变得更好：每当要对某个上下文做修改时，我们只需要理解这个上下文，而不必操心另一个。“每次只操心一个上下文”这点一直很重要，在如今这个信息爆炸、脑容量不够用的年代就愈发紧要。当然，往往只有在加入新数据库或新金融工具后，你才能发现这个坏味道。在程序刚开发出来、还在随着软件系统的能力不断演进时，上下文边界通常不是那么清晰的。

如果发生变化的两个方向自然地形成了序列——比如说，先从数据库取出数据，再对其进行金融逻辑处理——那么可以用*Split Phase*将两者分开，在其间定义一个清晰的数据结构。如果两个方向之间有更多的来回调用，那么就应该首先创建适当的模块，然后用*Move Function*把处理逻辑分开。如果函数内部混合了两类处理逻辑，应该首先用*Extract Function*将其分开，然后再做搬移。如果模块是以类的形式定义，那么可以用*Extract Class*来做拆分。
